const Phase = Object.freeze({ Idle: 'idle', Prep: 'prep', Work: 'work', Rest: 'rest', Finished: 'finished',
}); class Timer { constructor({ prep = 5, work = 20, rest = 10, totalSets = 8, onTick, onPhaseChange, onFinish }) { this.config = { prep, work, rest }; this.totalSets = totalSets; this.onTick = onTick || (() => {}); this.onPhaseChange = onPhaseChange || (() => {}); this.onFinish = onFinish || (() => {}); this.intervalId = null; this.reset(totalSets); } get state() { return { phase: this.phase, timeLeft: this.timeLeft, currentSet: this.currentSet, totalSets: this.totalSets, isPaused: this.isPaused, }; } start() { if (!this.isPaused) return; this.isPaused = false; if (this.phase === Phase.Idle) { this.phase = Phase.Prep; this.timeLeft = this.config.prep; this._emitPhase(); } if (!this.intervalId) { this.intervalId = setInterval(() => this._tick(), 1000); } } pause() { this.isPaused = true; if (this.intervalId) clearInterval(this.intervalId); this.intervalId = null; } reset(newTotalSets) { this.pause(); if (typeof newTotalSets === 'number' && newTotalSets > 0) { this.totalSets = newTotalSets; } this.phase = Phase.Idle; this.currentSet = 0; this.timeLeft = this.config.work; this.isPaused = true; this._emitTick(); } _tick() { this.timeLeft -= 1; this._emitTick(); if (this.timeLeft < 0) { if (this.phase === Phase.Prep) { this.phase = Phase.Work; this.timeLeft = this.config.work; this.currentSet = 1; this._emitPhase(); } else if (this.phase === Phase.Work) { if (this.currentSet >= this.totalSets) { this._finish(); return; } this.phase = Phase.Rest; this.timeLeft = this.config.rest; this._emitPhase(); } else if (this.phase === Phase.Rest) { this.phase = Phase.Work; this.currentSet += 1; this.timeLeft = this.config.work; this._emitPhase(); } this._emitTick(); } } _finish() { this.pause(); this.phase = Phase.Finished; this.isPaused = true; this._emitPhase(); this._emitTick(); this.onFinish(this.state); } _emitTick() { this.onTick(this.state); } _emitPhase() { this.onPhaseChange(this.state); }
} let audioContext;
let finishBuffer; export async function setupAudio() { if (audioContext) return; audioContext = new (window.AudioContext || window.webkitAudioContext)(); try { const res = await fetch('assets/audio/finish.mp3'); const arr = await res.arrayBuffer(); finishBuffer = await audioContext.decodeAudioData(arr); } catch (_) { finishBuffer = null; }
} function playBuffer(buffer) { if (!audioContext || !buffer) return; const source = audioContext.createBufferSource(); source.buffer = buffer; source.connect(audioContext.destination); source.start(0);
} function playTone(frequency, duration, type = 'sine') { if (!audioContext) return; const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.type = type; oscillator.frequency.value = frequency; const now = audioContext.currentTime; gainNode.gain.setValueAtTime(0, now); gainNode.gain.linearRampToValueAtTime(0.7, now + 0.01); oscillator.start(now); gainNode.gain.exponentialRampToValueAtTime(0.0001, now + duration); oscillator.stop(now + duration);
} const playShortBeep = () => playTone(880, 0.15, 'triangle');
const playLongBeep = () => playTone(440, 0.5, 'sine'); function playFinish() { if (finishBuffer) { playBuffer(finishBuffer); } else { playLongBeep(); setTimeout(() => playLongBeep(), 600); }
} const RADIUS = 140;
const CIRCUMFERENCE = 2 * Math.PI * RADIUS; const els = { timeLeft: document.getElementById('time-left'), status: document.getElementById('status'), setInfo: document.getElementById('set-info'), progressBar: document.getElementById('progress-bar'), startBtn: document.getElementById('startBtn'), pauseBtn: document.getElementById('pauseBtn'), resetBtn: document.getElementById('resetBtn'), setsInput: document.getElementById('sets-input'), body: document.body,
}; function initUI(totalSets, workTime) { els.progressBar.style.strokeDasharray = CIRCUMFERENCE; els.progressBar.style.strokeDashoffset = 0; els.timeLeft.textContent = workTime; els.status.textContent = 'BAÅžLA'; els.setInfo.textContent = `Set 0 / ${totalSets}`;
} function updateTimeLeft(value) { els.timeLeft.textContent = value >= 0 ? value : 0;
} function updateSetInfo(currentSet, totalSets, phase) { if (phase === 'idle' || phase === 'prep') { els.setInfo.textContent = `Set 0 / ${totalSets}`; } else if (phase !== 'finished') { els.setInfo.textContent = `Set ${currentSet} / ${totalSets}`; }
} function updateProgress(timeLeft, totalDuration) { const progress = timeLeft / totalDuration; const safe = Math.max(0, progress); const dashoffset = CIRCUMFERENCE * (1 - safe); els.progressBar.style.strokeDashoffset = dashoffset;
} function setPhase(phase) { els.body.classList.remove('phase-idle', 'phase-prep', 'phase-work', 'phase-rest', 'phase-finished'); els.body.classList.add(`phase-${phase}`); if (phase === 'prep') els.status.textContent = 'HAZIRLAN'; else if (phase === 'work') els.status.textContent = 'Ã‡ALIÅž'; else if (phase === 'rest') els.status.textContent = 'MOLA'; else if (phase === 'finished') els.status.textContent = 'BÄ°TTÄ°!'; else els.status.textContent = 'BAÅžLA';
} function setStartButtonLabel(text) { els.startBtn.textContent = text;
} function vibrate(ms = 120) { if (navigator.vibrate) navigator.vibrate(ms);
} const PREP_TIME = 5;
const WORK_TIME = 20;
const REST_TIME = 10; const savedSets = parseInt(localStorage.getItem('tabata_sets'), 10);
if (!Number.isNaN(savedSets) && savedSets > 0) { els.setsInput.value = savedSets;
} let totalSets = parseInt(els.setsInput.value, 10) || 8; initUI(totalSets, WORK_TIME); const timer = new Timer({ prep: PREP_TIME, work: WORK_TIME, rest: REST_TIME, totalSets, onTick: (state) => { updateTimeLeft(state.timeLeft); let totalDuration = 1; if (state.phase === Phase.Prep) totalDuration = PREP_TIME; else if (state.phase === Phase.Work) totalDuration = WORK_TIME; else if (state.phase === Phase.Rest) totalDuration = REST_TIME; updateProgress(state.timeLeft, totalDuration); updateSetInfo(state.currentSet, state.totalSets, state.phase); if (state.phase === Phase.Prep) { if (state.timeLeft > 0) playShortBeep(); } else if (state.phase === Phase.Work || state.phase === Phase.Rest) { if (state.timeLeft === 0) { if (!(state.phase === Phase.Work && state.currentSet >= state.totalSets)) { playLongBeep(); } } else if (state.timeLeft > 0 && state.timeLeft <= 3) { playShortBeep(); } } }, onPhaseChange: (state) => { setPhase(state.phase); vibrate(120); }, onFinish: (state) => { playFinish(); els.timeLeft.textContent = 'ðŸŽ‰'; els.setInfo.textContent = `Tebrikler! ${state.totalSets} set tamamlandÄ±.`; updateProgress(0, 1); vibrate(200); }
}); els.startBtn.addEventListener('click', async () => { await setupAudio(); const wasIdle = timer.state.phase === Phase.Idle; timer.start(); if (!wasIdle) setStartButtonLabel('Devam');
}); els.pauseBtn.addEventListener('click', () => { timer.pause(); setStartButtonLabel('Devam');
}); els.resetBtn.addEventListener('click', () => { totalSets = parseInt(els.setsInput.value, 10) || 8; timer.reset(totalSets); setPhase(Phase.Idle); setStartButtonLabel('BaÅŸlat'); initUI(totalSets, WORK_TIME);
}); els.setsInput.addEventListener('change', () => { const v = parseInt(els.setsInput.value, 10) || 8; localStorage.setItem('tabata_sets', String(v)); totalSets = v; timer.reset(totalSets); setPhase(Phase.Idle); setStartButtonLabel('BaÅŸlat'); initUI(totalSets, WORK_TIME);
}); window.addEventListener('keydown', (e) => { if (e.code === 'Space') { e.preventDefault(); if (timer.state.isPaused) { els.startBtn.click(); } else { els.pauseBtn.click(); } }
}); if ('serviceWorker' in navigator && window.isSecureContext) { const swPath = (location.pathname.includes('/dist/')) ? './sw.js' : './dist/sw.js'; navigator.serviceWorker.register(swPath).catch(() => {});
}